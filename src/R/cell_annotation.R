#!/usr/bin/Rscript 

### This script takes the scRNA-seq data generated by SHARE-seq and
### perform cell annotation using Seurat label transfer approach.

source("/usr/local/bin/cell_annotation_helper_functions.R")
#source("/data/pinello/PROJECTS/2023_02_SHARE_Pipeline/epi-SHARE-seq-pipeline/src/R/cell_annotation_helper_functions.R")

suppressMessages(library(Seurat))
suppressMessages(library(Matrix))
suppressMessages(library(future))
suppressMessages(library(logr))
suppressMessages(library(dplyr))
suppressMessages(library(grid))
suppressMessages(library(gridExtra))
suppressMessages(library(ggplot2))
suppressMessages(library(patchwork))
suppressMessages(library(cowplot))
suppressMessages(library(EnsDb.Mmusculus.v79))
suppressMessages(library(EnsDb.Hsapiens.v86))
suppressMessages(library(optparse))

options("logr.notes" = FALSE)
options(future.globals.maxSize=10e9)
options(Seurat.object.assay.version = "v5")
set.seed(1234)

option_list = list(
    # input parameters
    make_option(c("--prefix"), type="character", default="prefix", 
                help="Sample or project name", 
                metavar="character"),
    
    make_option(c("--reference_data_name"), type="character", default="reference", 
                help="Reference data file.", 
                metavar="character"),
    
    make_option(c("--reference_label"), type="character", default="cell_type", 
                help="Which label used for annotation.", 
                metavar="character"),
    
    make_option(c("--query_data"), type="character", default="query.rds", 
                help="Query data.", 
                metavar="character"),
    
    # downsampling parameters
    make_option(c("--downsampling"), type="character", default="FALSE", 
                help="Whether or not down sample the reference data. 
                      Set it as true when the there are too many cells inrefence. Default: FALSE", 
                metavar="character"),
    
    make_option(c("--num_cells", type="integer", default=5000,
                 help="Number of cells after downsampling. Default: 5000"),
                metavar = "number"),
    
    # reference genome parameters
    make_option(c("--genome"), type="character", default="hg38", 
                help="Which genome is used as reference. Currently available options: hg38; mm10. Default: hg38", 
                metavar="character"),
    
    make_option(c("--gene_id_to_symbol"), type="character", default="TRUE", 
                help="Whether or not convert the gene id to symnol. 
                      Set true if the reference data uses gene id as feature name.", 
                metavar="character"),
    
    # output parameters
    make_option(c("--save_seurat"), type="character", default="FALSE", 
                help="Whether or not save the Seurat object", 
                metavar="character")
)

opt_parser <- OptionParser(option_list=option_list)
opt <- parse_args(opt_parser)

####################################################
# Get input parameter
prefix <- opt$prefix
reference_data_name <- opt$reference_data_name
reference_label <- opt$reference_label
query_data <- opt$query_data

# Downsampling parameters
downsampling <- as.logical(opt$downsampling)
num_cells <- opt$num_cells

# Reference genome
genome <- opt$genome
gene_id_to_symbol <- as.logical(opt$gene_id_to_symbol)

# Output
save_seurat <- as.logical(opt$save_seurat)

# Create log file
logfile <- file.path(glue::glue("{prefix}.cell.annotation.logfile.{genome}.txt"))
lf <- log_open(logfile)


#########################################################
# Loading data
tryCatch(
    {
        log_print("# Loading reference data...")
        
        adata <- read_h5ad(glue::glue("{reference_data_name}.h5ad"))
        counts <- t(as.matrix(adata$raw$X))
        colnames(counts) <- adata$obs_names
        rownames(counts) <- adata$var_names
        metadata <- as.data.frame(adata$obs)
        obj.ref <- CreateSeuratObject(counts = counts, assay = "RNA")
        obj.ref <- AddMetaData(obj.ref, metadata)
        rm(counts)
        gc()
    },
    error = function(cond){
        log_print("ERROR: loading reference data")
        log_print(cond)
    }
)

# Read query data
tryCatch(
    {
        log_print("# Reading query data...")
        obj.query <- readRDS(query_data)
        log_print("SUCCESSFUL: Reading query data")
    
    },
    error = function(cond) {
        log_print("ERROR: Reading query data")
        log_print(cond)
    }
)


# Convert gene ID to symbol for reference data
if(gene_id_to_symbol){
    tryCatch(
    {
        log_print("# Converting gene id to symbol for reference data")
        
        if(genome == "hg38" | genome == "hg37"){
            gene.id <- ensembldb::select(EnsDb.Hsapiens.v86, 
                                         keys= rownames(obj.ref), 
                                         keytype = "GENEID", 
                                         columns = c("SYMBOL","GENEID"))
    
        } else if(genome == "mm10" | genome == "mm9"){
            gene.id <- ensembldb::select(EnsDb.Mmusculus.v79, 
                                         keys = rownames(obj.ref), 
                                         keytype = "GENEID", 
                                         columns = c("SYMBOL","GENEID"))
        }
        
        # remove genes with empty symbol
        gene.id <- subset(gene.id, gene.id$SYMBOL != "")

        # make gene symbol unique
        gene.id$Unique_SYMBOL <- make.unique(gene.id$SYMBOL, "")

        # API for Seurat v5
        counts <- LayerData(obj.ref, layer = 'counts', assay = 'RNA', features=gene.id$GENEID)
        rownames(counts) <- gene.id$Unique_SYMBOL

        obj.ref <- CreateSeuratObject(counts = counts, 
                                      meta.data = obj.ref@meta.data)
        
        log_print("SUCCESSFUL: Converting gene id to symbol for reference data")

    },
    error = function(cond) {
        log_print("ERROR: Converting gene id to symbol for reference data")
        log_print(cond)
    }
)
}

# Subset genes
tryCatch(
    {
        log_print("# Subseting reference and query data with common genes")
        
        gene.common <- intersect(rownames(obj.ref), rownames(obj.query))
        
        # subset reference data
        counts <- LayerData(obj.ref, 
                            layer = 'counts', 
                            assay = 'RNA', 
                            features=gene.common)
        
        obj.ref <- CreateSeuratObject(counts = counts, 
                                      assay = "RNA",
                                      meta.data = obj.ref@meta.data) %>%
                    NormalizeData(verbose = FALSE) %>%
                    FindVariableFeatures() %>%
                    ScaleData() %>%
                    RunPCA(verbose=FALSE)
        
        # subset query data
        counts <- LayerData(obj.query, layer = 'counts', assay = 'RNA', features=gene.common)
        obj.query <- CreateSeuratObject(counts = counts, 
                                        assay = "RNA",
                                        meta.data = obj.query@meta.data) %>%
                    NormalizeData(verbose = FALSE) %>%
                    FindVariableFeatures() %>%
                    ScaleData() %>%
                    RunPCA(verbose=FALSE)
        
        log_print(glue::glue("# Found {length(gene.common)} common genes between reference and query data"))
        log_print("SUCCESSFUL: Subseting reference and query data with common genes")
    },
     error = function(cond) {
        log_print("ERROR: Subseting reference and query data with common genes")
        log_print(cond)
    }
    
)


# Subset reference data
if(downsampling){
    tryCatch(){
        log_print("# Down sampling reference data")
        # 
        obj.ref <- SketchData(object = obj.ref, 
                             ncells = num_cells, 
                             method = "LeverageScore", 
                             sketched.assay = "sketch")
        DefaultAssay(obj.ref) <- "sketch"
    
    },
     error = function(cond) {
        log_print("ERROR: Down sampling reference data")
        log_print(cond)
    }


}


# Predict labels for query dataset
tryCatch(
    {
        log_print("# Predicting labels for query data")
        
        transfer.anchors <- FindTransferAnchors(
            reference = obj.ref,
            query = obj.query,
            reduction = "cca",
            verbose = TRUE
        )
        
        predictions <- TransferData(anchorset = transfer.anchors, 
                                    refdata = obj.ref[[reference_label]][, 1],
                                    weight.reduction = obj.query[["pca"]],
                                    dims = 1:30,
                                    verbose = TRUE)

        write.csv(predictions, 
                  file = glue::glue("{prefix}.cell.annotation.prediction.{genome}.csv"),
                  quote = FALSE)
        
        log_print("SUCCESSFUL: Predicting labels for query data")
    },
     error = function(cond) {
        log_print("ERROR: Predicting labels for query data")
        log_print(cond)
    }
    
)

## Plotting
tryCatch(
    {
        log_print("# Plotting")
        
        obj.query <- readRDS(query_data)
        obj.query <- AddMetaData(obj.query, metadata = predictions)
        
        p <- DimPlot(obj.query, group.by = "predicted.id", 
                    label = FALSE, reduction = "umap", raster='FALSE')
        
        ggsave(plot = p, 
              filename = glue::glue("{prefix}.cell.annotation.labels.{genome}.png"), 
              width = 16, height = 12)
        
        
        sel_cols <- grep("prediction.score|seurat_clusters", 
                         colnames(obj.query@meta.data), value=TRUE)
        sel_cols <- sel_cols[1:length(sel_cols) - 1]
        
        df <- obj.query@meta.data %>%
        subset(select = sel_cols) %>%
        tidyr::gather(key = "celltype", value = "score", -seurat_clusters)
        df$celltype <- stringr::str_replace_all(df$celltype, "prediction.score.", "")
        
        pdf(file = glue::glue("{prefix}.cell.annotation.scores.{genome}.pdf"), 
            width = 10, height = 6)
        
        for(seurat_cluster in sort(unique(df$seurat_clusters))){
            p <- subset(df, seurat_clusters == seurat_cluster) %>%
                ggplot(aes(x = celltype, y = score)) +
                geom_violin(aes(fill = celltype), scale = "width") +
                theme_cowplot() +
                xlab("") + ylab("Predictied score") +
                ggtitle(glue::glue("cluster: {seurat_cluster}")) +
                theme(axis.text.x = element_text(angle=60, hjust = 1),
                     legend.position = "none",
                     plot.title = element_text(hjust = 0.5))
            
            print(p)
        }  
        
        dev.off()
        
        log_print("SUCCESSFUL: Plotting")  

    },
    error = function(cond) {
        log_print("ERROR: Plotting predicted labels")
        log_print(cond)
    }

)

## Saving Seurat object
tryCatch(
    {
        if(save_seurat){
            log_print("# Saving seurat object for query data")
            saveRDS(obj.query, file = glue::glue("{prefix}.cell.annotation.{genome}.rds"))
            log_print("SUCCESSFUL: Saving seurat object for query data")   
        }
        
    },
     error = function(cond) {
        log_print("ERROR: Saving seurat object for query data")
        log_print(cond)
    }
    
)
